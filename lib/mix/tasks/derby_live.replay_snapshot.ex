defmodule Mix.Tasks.DerbyLive.ReplaySnapshot do
  @moduledoc """
  Replays derby race snapshots against the API.

  This task reads snapshots generated by `mix derby_live.generate_snapshots`
  and POSTs them to the Derby Live API, simulating the sync utility.

  ## Usage

      mix derby_live.replay_snapshot <json_path> <event_key> [options]

  ## Arguments

    * `json_path` - Path to the JSON snapshots file
    * `event_key` - The event key to use for the API

  ## Options

    * `--step N` - Upload only snapshot N (0-indexed)
    * `--all` - Upload all snapshots sequentially
    * `--delay MS` - Milliseconds between uploads when using --all (default: 2000)
    * `--api-key KEY` - API key for authentication (or set DERBY_API_KEY env var)
    * `--server URL` - Server URL (default: http://localhost:4000)

  ## Examples

      # Upload snapshot 0 (initial setup)
      $ mix derby_live.replay_snapshot tmp/snapshots.json ABC123 --step 0

      # Upload snapshot 1 (first heat completed)
      $ mix derby_live.replay_snapshot tmp/snapshots.json ABC123 --step 1

      # Upload all snapshots with 3 second delays
      $ mix derby_live.replay_snapshot tmp/snapshots.json ABC123 --all --delay 3000

      # Use custom API key and server
      $ mix derby_live.replay_snapshot tmp/snapshots.json ABC123 --all \\
          --api-key mykey123 --server https://derby.example.com

  ## Environment Variables

    * `DERBY_API_KEY` - API key for authentication (alternative to --api-key)
  """
  use Mix.Task

  alias DerbyLive.SyncSimulator.Generator

  @shortdoc "Replays derby race snapshots against the API"

  @switches [
    step: :integer,
    all: :boolean,
    delay: :integer,
    api_key: :string,
    server: :string
  ]

  @default_server "http://localhost:4000"
  @default_delay 2000

  @impl Mix.Task
  def run(args) do
    # Start the app so we have access to Req
    Mix.Task.run("app.start")

    {opts, positional, _invalid} = OptionParser.parse(args, switches: @switches)

    case positional do
      [json_path, event_key] ->
        replay(json_path, event_key, opts)

      _ ->
        print_usage()
    end
  end

  defp replay(json_path, event_key, opts) do
    unless File.exists?(json_path) do
      Mix.shell().error("Error: JSON file not found: #{json_path}")
      System.halt(1)
    end

    api_key = get_api_key(opts)

    unless api_key do
      Mix.shell().error("Error: API key required. Use --api-key or set DERBY_API_KEY env var")
      System.halt(1)
    end

    server = Keyword.get(opts, :server, @default_server)
    delay = Keyword.get(opts, :delay, @default_delay)

    case Generator.read_snapshots(json_path) do
      {:ok, snapshots} ->
        snapshot_count = length(snapshots)
        Mix.shell().info("Loaded #{snapshot_count} snapshots from #{json_path}")

        cond do
          Keyword.has_key?(opts, :step) ->
            step = Keyword.get(opts, :step)
            upload_single(snapshots, step, event_key, api_key, server)

          Keyword.get(opts, :all, false) ->
            upload_all(snapshots, event_key, api_key, server, delay)

          true ->
            Mix.shell().info("")
            Mix.shell().info("Available snapshots: 0-#{snapshot_count - 1}")
            Mix.shell().info("Use --step N to upload a specific snapshot")
            Mix.shell().info("Use --all to upload all snapshots sequentially")
        end

      {:error, reason} ->
        Mix.shell().error("Error reading snapshots: #{inspect(reason)}")
        System.halt(1)
    end
  end

  defp upload_single(snapshots, step, event_key, api_key, server) do
    snapshot_count = length(snapshots)

    if step < 0 or step >= snapshot_count do
      Mix.shell().error("Error: Step #{step} out of range (0-#{snapshot_count - 1})")
      System.halt(1)
    end

    snapshot = Enum.at(snapshots, step)
    upload_snapshot(snapshot, step, event_key, api_key, server)
  end

  defp upload_all(snapshots, event_key, api_key, server, delay) do
    snapshot_count = length(snapshots)

    snapshots
    |> Enum.with_index()
    |> Enum.each(fn {snapshot, index} ->
      upload_snapshot(snapshot, index, event_key, api_key, server)

      # Wait between uploads (except after the last one)
      if index < snapshot_count - 1 do
        Mix.shell().info("  Waiting #{delay}ms...")
        Process.sleep(delay)
      end
    end)

    Mix.shell().info("")
    Mix.shell().info("Completed uploading #{snapshot_count} snapshots!")
  end

  defp upload_snapshot(snapshot, index, event_key, api_key, server) do
    racer_count = length(Map.get(snapshot, "racers", []))
    completed_heats = count_completed_heats(snapshot)

    Mix.shell().info("")
    Mix.shell().info("Uploading snapshot #{index}:")
    Mix.shell().info("  Racers: #{racer_count}")
    Mix.shell().info("  Completed heats: #{completed_heats}")

    payload = %{
      "event_key" => event_key,
      "racers" => Map.get(snapshot, "racers", []),
      "racer_heats" => Map.get(snapshot, "racer_heats", [])
    }

    url = "#{server}/api/data"

    case do_upload(url, payload, api_key) do
      {:ok, response} ->
        Mix.shell().info("  Result: #{inspect(response)}")

      {:error, reason} ->
        Mix.shell().error("  Error: #{inspect(reason)}")
    end
  end

  defp do_upload(url, payload, api_key) do
    case Req.post(url,
           json: payload,
           headers: [{"x-api-key", api_key}]
         ) do
      {:ok, %{status: status, body: body}} when status in 200..299 ->
        {:ok, body}

      {:ok, %{status: status, body: body}} ->
        {:error, "HTTP #{status}: #{inspect(body)}"}

      {:error, exception} ->
        {:error, Exception.message(exception)}
    end
  end

  defp count_completed_heats(snapshot) do
    snapshot
    |> Map.get("racer_heats", [])
    |> Enum.filter(fn rh -> Map.get(rh, "finish_place") != nil end)
    |> Enum.map(fn rh -> Map.get(rh, "heat_number") end)
    |> Enum.uniq()
    |> length()
  end

  defp get_api_key(opts) do
    Keyword.get(opts, :api_key) || System.get_env("DERBY_API_KEY")
  end

  defp print_usage do
    Mix.shell().error("Usage: mix derby_live.replay_snapshot <json_path> <event_key> [options]")
    Mix.shell().error("")
    Mix.shell().error("Options:")
    Mix.shell().error("  --step N       Upload only snapshot N (0-indexed)")
    Mix.shell().error("  --all          Upload all snapshots sequentially")
    Mix.shell().error("  --delay MS     Milliseconds between uploads (default: 2000)")
    Mix.shell().error("  --api-key KEY  API key for authentication")
    Mix.shell().error("  --server URL   Server URL (default: http://localhost:4000)")
    Mix.shell().error("")
    Mix.shell().error("Examples:")
    Mix.shell().error("  mix derby_live.replay_snapshot tmp/snapshots.json ABC123 --step 0")

    Mix.shell().error(
      "  mix derby_live.replay_snapshot tmp/snapshots.json ABC123 --all --delay 3000"
    )
  end
end
